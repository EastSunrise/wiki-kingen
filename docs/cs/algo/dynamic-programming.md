# 动态规划

动态规划（Dynamic Programming）和[分治算法](divide-and-conquer.md)相似，都是将子问题的解组合来求解原问题。但是分治算法在划分子问题时，存在子问题重复计算的情况。动态规划算法的处理方式是，对每个子问题只作一次求解，然后将其解保存在一个表中，从而避免了相同子问题的重复计算，即付出额外的内存空间来节省计算时间。

动态规划方法通常用来求解最优化问题（optimization problem），这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。步骤通常如下：

1. 刻画一个最优解的结构特征；
2. 递归地定义最优解的值；
3. 计算最优解的值，通常采用自底向上的方法；
4. 利用计算出的信息构造一个最优解。（如果仅需要一个最优值，可以忽略这步）

动态规划有两种等价的实现方法。

第一种方法称为**带备忘的自顶向下法**（top-down with memoization），此方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解（通常保存在一个数组或散列表中）。当需要一个子问题的解时，首先检查是否已经保存过此解，如果是，则五接返回保存的值 从而节省了计算时间；否则，按通常方式计算这个子问题。

第二种方法称为**自底向上法**（bottom-up method），这种方法一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的”子问题的求解。因而我们可以将子问题按规模排序，按由小至大的顺序进行求解。当求解某个子问题时，它所依赖的那些更小的子问题都已求解完毕，结果已经保存。每个子问题只需求解一次，当我们求解它（也是第一次遇到它）时，它的所有前提子问题都已求解完成。

## 示例

下面用斐波那契数列求解问题作简单说明。该算法最原始的递归实现如下：

```java
int f(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    return f(n - 1) + f(n - 2);
}
```

如果采用带备忘的自顶向下法，则需要创建一个数组来保存已求解的值，

```java
int[] memo = new int[n + 1];
int f_top_down(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    if (memo[n] > 0) {
        return memo[n];
    }
    memo[n] = f_top_down(n - 1) + f_top_down(n - 2);
    return memo[n];
}
```

如果采用自底向上法，则需要从小到大的顺序依次计算每一项的值，

```java
int f_bottom_up(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    int[] memo = new int[n + 1];
    memo[0] = memo[1] = 1;
    for (int i = 2; i <= n; i++) {
        memo[i] = memo[i - 2] + memo[i - 1];
    }
    return memo[n];
}
```

## 参考

- Cormeo T H, et al. 算法导论. 原书第 3 版. 第 15 章.
